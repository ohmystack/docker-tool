#!/bin/bash

# default ENVs
DOCKER_SOCK='unix:///var/run/docker.sock'

DOCKER="docker -H $DOCKER_SOCK"

# -----------------
# Help
# -----------------

print_usage() {
	# NOTE: After modification, remember to
	#       1. Run `:Align |` in vim to align the help info with '|' seperator
	#       2. Sort the action list by alphabet
	cat <<-EOF
	
	Usage:
	sudo ./docker-tool <action> [args...]

	Actions:
		clean-img                        | Clean dangling images
		clean-vol                        | (DANGEROUS!!!) Clean dangling volumes, who are not referenced by any containers
		img [name]                       | Grep image by given <name>
		logs <container-id/name>         | == docker logs --tail=50 -f <container-id/name>
		net <container-id/name>          | Show network info (mode, veth pair, ...) of a container
		ns-net <container-id/name>       | Enter the net namespace of a container, with all host's tools available. Use "exit" to exit
		pid <container-id/name>          | Get the pid of a container
		ps <name>                        | Grep from docker ps
		run ...                          | == docker run -it --rm ...
		ssh <container-id/name or image> | Enter the bash/sh of a container or image

	EOF
}

# -----------------
# Utils - common
# -----------------

# echo with 256 color
# Usage: echo_color <color_id> <text>
echo_color() {
	dye=$(echo -e "\e[38;5;${1}m")
	stop_dye=$(echo -e "\e[0m")
	echo "$dye$2$stop_dye"
}

echo_err() {
	echo_color 202 "$1" 1>&2
}

command_exists() {
	which $1 > /dev/null 2>&1
}

# Ensure there are <count> args
# Usage: ensure_count_args 1 "$@"
ensure_count_args() {
	local require=$1
	shift
	if [ "$#" -lt $require ]; then
		echo_err "Error: need $require args at least, but $# given"
		exit 1
	fi
}

ensure_command_exists() {
	if ! command_exists $1 ; then
		echo_err "Error: cannot find '$1' program"
		exit 1
	fi
}

# Prompt a string to ask user y/n
# It returns exit code to indicate user's answer. 
# Exit code 0 -> ok, 1 -> error
# Usage:
#   if ask_user [what you want to ask] ; then ... ; fi
ask_user() {
	local answer
	echo ""
	read -p "$1 (y/n) " answer
	case $answer in
		"y"*|"Y"*)
			return 0
			;;
		"n"*|"N"*)
			return 1
			;;
	esac
	return 1
}

# -----------------
# Utils - Docker
# -----------------

# Whether this is a Docker image name, already pulled
# Exit code 0 -> ok, 1 -> error
# Usage:
#   if is_image <name> ; then ... ; fi
is_image() {
	local keyword=$1
	# If keyword doesn't have a colon, which means no tag specified, add "latest" tag for it
	if [ $(echo $keyword | cut -s -d ':' -f 1 | wc -l) -eq 0 ] ; then
		keyword=${keyword}:latest
	fi
	if [ $($DOCKER images -q $keyword | wc -l) -gt 0 ] ; then
		return 0
	fi
	return 1
}

# Whether this is a Docker container ID/name
# Exit code 0 -> ok, 1 -> error
# Usage:
#   if is_container <name> ; then ... ; fi
is_container() {
	local keyword=$1
	# Try to match with container ID
	if [ $($DOCKER ps -q -f "id=$keyword" | wc -l) -gt 0 ] ; then
		return 0
	fi
	# Try to match with container fullname
	for c_name in $($DOCKER ps --format "{{.Names}}") ; do
		if [ $c_name = $keyword ] ; then
			return 0
		fi
	done
	return 1
}

# Ensure that $1 is a running container id or name
ensure_is_container() {
	if ! is_container $1 ; then
		echo_err "'$1' is not a container id or name"
		exit 1
	fi
}

# -----------------
# Actions
# -----------------

action_pid() {
	ensure_count_args 1 "$@"
	ensure_is_container $1

	$DOCKER inspect -f {{.State.Pid}} $1
}

action_net() {
	ensure_count_args 1 "$@"
	ensure_command_exists nsenter
	ensure_command_exists ethtool
	ensure_is_container $1

	local pid=$(action_pid $1)

	local network_mode=$($DOCKER inspect -f {{.HostConfig.NetworkMode}} $1)
	echo_color 135 "NetworkMode: $network_mode"
	case $network_mode in
		'default')
			local in_veth_statistcs=$(nsenter -t $pid -n -F -- ethtool --statistics eth0 | tail -1)
			local out_veth_id=${in_veth_statistcs##*:}  # Get the value after ":"
			local out_veth_dev=$(ip link | grep $out_veth_id | tr -d ' ' | cut -d ':' -f 2)

			echo_color 222 "(Outside)"
			ip addr show $out_veth_dev

			echo_color 39 "(Inside container)"
			nsenter -t $pid -n -F -- ip addr show eth0
			;;
		'host')
			nsenter -t $pid -n -F -- ip addr show eth0
			;;
		'container:'*)
			local cid=${network_mode##*:}  # Get the value after ":"
			echo_color 135 "(In container:$cid)"
			action_net $cid
			;;
	esac
}

action_img() {
	if [ $# -lt 1 ] ; then
		exec $DOCKER images
	fi
	$DOCKER images | grep --color=auto $1
}

action_clean_img() {
	if [ $($DOCKER images -f "dangling=true" -q | wc -l) -eq 0 ] ; then
		echo "Already clean."
		return 0
	else
		$DOCKER images -f "dangling=true"
	fi

	if ask_user "Are you sure to delete these images?" ; then
		$DOCKER rmi $($DOCKER images -f "dangling=true" -q)
	else
		echo "Canceled."
	fi
}

action_clean_vol() {
	if [ $($DOCKER volume ls -f "dangling=true" -q | wc -l) -eq 0 ] ; then
		echo "Already clean."
		return 0
	else
		$DOCKER volume ls -f "dangling=true"
	fi

	if ask_user "Are you sure to delete these volumes?" ; then
		$DOCKER volume rm $($DOCKER volume ls -f "dangling=true" -q)
	else
		echo "Canceled."
	fi
}

action_ns_net() {
	ensure_count_args 1 "$@"
	ensure_command_exists nsenter
	ensure_is_container $1

	echo '(Remind: type "exit" to exit the namespace)'
	nsenter --target $(action_pid $1) --net
}

action_ssh() {
	ensure_count_args 1 "$@"
	local name=$1

	if is_container $name ; then
		# We don't use 'which' to detect command in containers because 'which' is not installed in some images.
		# But in most cases, 'ls' is installed. Nor, probably there's no other commands availble.
		if $DOCKER exec -it $name ls /bin/bash > /dev/null 2>&1 ; then
			echo_color 148 "Enter container '${name}', using /bin/bash"
			$DOCKER exec -it $name /bin/bash
			return $?
		elif $DOCKER exec -it $name ls > /dev/null 2>&1 ; then
			echo_color 148 "Enter container '${name}', using /bin/sh"
			$DOCKER exec -it $name /bin/sh
			return $?
		fi
		echo_err "cannot find '/bin/bash' or '/bin/sh' in container: $name"
		return 1
	fi

	if is_image $name ; then
		echo_color 148 "Enter image '${name}'"

		echo_color 64 "- Try to use /bin/bash"
		$($DOCKER run -it --rm --entrypoint=/bin/bash $name)
		local exit_code=$?
		echo $exit_code
		if [ ! $exit_code -eq 125 ] && [ ! $exit_code -eq 127 ] ; then  # exit code 125: exec failed, 127: no such command
			return $exit_code
		fi

		echo_color 64 "- Try to use /bin/sh"
		$DOCKER run -it --rm --entrypoint=/bin/sh $name
		if [ ! $? -eq 125 ] && [ ! $? -eq 127 ] ; then
			return $?
		fi

		echo_err "cannot find '/bin/bash' or '/bin/sh' in image: $name"
		return 1
	fi

	echo_err "'$name' is not a container id/fullname, nor an image name"
	exit 1
}

action_run() {
	$DOCKER run -it --rm "$@"
}

action_logs() {
	ensure_count_args 1 "$@"
	ensure_is_container $1

	$DOCKER logs --tail=50 -f "$@"
}

action_ps() {
	ensure_count_args 1 "$@"
	$DOCKER ps | grep --color=auto $1
}

# -----------------
# Main
# -----------------

if [ -n "$1" ]; then
	case $1 in
		'help'|'-h'|'--help')
			print_usage
			;;
		'pid')
			shift
			action_pid "$@"
			;;
		'net')
			shift
			action_net "$@"
			;;
		'img'|'images')
			shift
			action_img "$@"
			;;
		'clean-img'|'clean-images')
			shift
			action_clean_img "$@"
			;;
		'clean-vol'|'clean-volume')
			shift
			action_clean_vol "$@"
			;;
		'ns-net')
			shift
			action_ns_net "$@"
			;;
		'ssh')
			shift
			action_ssh "$@"
			;;
		'run')
			shift
			action_run "$@"
			;;
		'logs'|'log')
			shift
			action_logs "$@"
			;;
		'ps')
			shift
			action_ps "$@"
			;;
		*)
			echo_err "Error: unknown action '$1'"
			exit 1
			;;
	esac
else
	print_usage
fi
